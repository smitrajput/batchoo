"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const penpal_1 = __importDefault(require("penpal"));
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const moment_1 = __importDefault(require("moment"));
const is_buffer_1 = __importDefault(require("is-buffer"));
const version_1 = __importDefault(require("./version"));
const AuthereumProvider_1 = __importDefault(require("./AuthereumProvider"));
const config_1 = require("./config");
const utils_1 = require("./utils");
// Serialize object for postMessage to iframe.
// Converts references to values.
const serializeMessageObj = (obj) => {
    const tx = {};
    for (let k in obj) {
        let v = obj[k];
        if (typeof v === 'object' && v.toString === 'function') {
            v = v.toString('hex');
        }
        tx[k] = v;
    }
    return tx;
};
const defaultIframeStyle = {
    width: 0,
    height: 0,
    top: 0,
    left: 0
};
// This is a placeholder notify object stub until notifier script url is
// injected into page after iframe is loaded.
const defaultNotifier = {
    notify: (type, message) => {
        console.log(type, message);
        return {
            dismiss: () => {
                // noop
            }
        };
    }
};
class Authereum extends eventemitter3_1.default {
    constructor(config) {
        super();
        this.notifier = defaultNotifier;
        this.iframeReady = false;
        this._configReady = false;
        this.iframeConnecting = null;
        this.cacheReady = false;
        this.readyEmitted = false;
        this._widgetEnabled = false;
        this.iframeStyle = defaultIframeStyle;
        this.blockedPopupRedirect = true;
        this.notificationsMap = {};
        this._heartbeatStarted = false;
        this._backoffTimeout = 1;
        this._userConfig = null;
        this._asymmetricEncryptionKey = null;
        this._authereumQueryParams = {};
        this._injectedElements = [];
        this._destroyed = false;
        // NOTE: keep this sync
        this._init = (config) => {
            if (typeof config === 'string') {
                let network = config;
                this.networkName = (network || '').trim().toLowerCase();
                if (['mainnet', 'ropsten', 'rinkeby', 'kovan', 'goerli'].includes(this.networkName)) {
                    this.xsUri = config_1.defaultConfig.xsUri(this.networkName);
                }
                else if (config === 'localhost') {
                    this.xsUri = 'http://localhost:3002';
                    this.networkName = 'kovan';
                }
                else {
                    throw new Error('Unsupported network');
                }
            }
            else {
                config = config || {};
                this.networkName = config.networkName || 'mainnet';
                this.xsUri = config.xsUri || config_1.defaultConfig.xsUri(this.networkName);
                this._apiKey = config.apiKey;
            }
            if (config.redirectUri) {
                this.redirectUri = config.redirectUri;
            }
            else {
                this.redirectUri = window.location.href;
            }
            this.iframeStyle = {
                width: 0,
                height: 0,
                top: 0,
                left: 0
            };
            this.redirectUri = this.redirectUri || window.location.href;
            this.provider = new AuthereumProvider_1.default(this);
            this._setupNotifier();
            this._connectToChildIframe()
                .catch(() => {
                this._startHeartbeat(true);
            });
            this._setupCache();
            this._cacheAuthereumQueryParams();
            this._setupSigningKey();
            this._setupResizeListener();
            this._emitReadyEvent();
            window.addEventListener('focus', this._handleWindowFocus, false);
        };
        // NOTE: keep this sync
        this._setConfig = (config) => {
            if (typeof this._userConfig === 'string') {
                let network = this._userConfig;
                this.networkName = (network || '').trim().toLowerCase();
                this._userConfig = {
                    networkName: this.networkName,
                    xsUri: config_1.defaultConfig.xsUri(this.networkName)
                };
            }
            const { apiKey, apiUri, rpcUri, webUri, notifierUri, networkName, networkId, disableNotifications, blockedPopupRedirect } = this._userConfig || {};
            if (apiKey) {
                this._apiKey = apiKey;
            }
            // userConfig overrides regular config
            if (apiUri) {
                this.apiUri = apiUri;
            }
            else if (config.apiUri) {
                this.apiUri = config.apiUri;
            }
            // userConfig overrides regular config
            if (rpcUri) {
                this.rpcUri = rpcUri;
            }
            else {
                this.rpcUri = config.rpcUri;
            }
            // userConfig overrides regular config
            if (webUri) {
                this.webUri = webUri;
            }
            else if (config.webUri) {
                this.webUri = config.webUri;
            }
            // userConfig overrides regular config
            if (notifierUri) {
                this.notifierUri = notifierUri;
            }
            else if (config.notifierUri) {
                this.notifierUri = config.notifierUri;
            }
            // userConfig overrides regular config
            if (networkName) {
                this.networkName = networkName;
            }
            else if (config.networkName) {
                this.networkName = config.networkName;
            }
            // userConfig overrides regular config
            if (networkId) {
                this.networkId = networkId;
            }
            else if (config.networkId) {
                this.networkId = config.networkId;
            }
            // userConfig overrides regular config
            if (typeof disableNotifications === 'boolean') {
                this.disableNotifications = disableNotifications;
            }
            else if (typeof config.disableNotifications === 'boolean') {
                this.disableNotifications = config.disableNotifications;
            }
            // userConfig overrides regular config
            if (typeof blockedPopupRedirect === 'boolean') {
                this.blockedPopupRedirect = blockedPopupRedirect;
            }
            else if (typeof config.blockedPopupRedirect === 'boolean') {
                this.blockedPopupRedirect = config.blockedPopupRedirect;
            }
        };
        this._setupCache = () => __awaiter(this, void 0, void 0, function* () {
            yield Promise.all([
                this._cacheLoginKeyAddress(),
                this._cacheIsAuthenticated(),
                this._cacheAccountAddress()
            ]);
            this.cacheReady = true;
        });
        this._handleWindowFocus = () => {
            return this._postMessageToChild({
                method: 'onWindowFocus'
            });
        };
        this._resetCache = () => __awaiter(this, void 0, void 0, function* () {
            return this._setupCache();
        });
        this._setupNotifier = () => __awaiter(this, void 0, void 0, function* () {
            yield this._tilConfigReady();
            if (!this.notifierUri) {
                return;
            }
            yield this._injectScript(this.notifierUri, 'authereum-notifier');
            if (window.AuthereumNotifier) {
                this.notifier = new window.AuthereumNotifier({
                    networkId: this.networkId,
                    disableNotifications: this.disableNotifications,
                    context: this
                });
            }
        });
        this._injectScript = (sourceUrl, id = '') => __awaiter(this, void 0, void 0, function* () {
            yield this._tilDomReady();
            return new Promise((resolve, reject) => {
                if (!sourceUrl) {
                    throw new Error('sourceUrl is required');
                }
                if (document.getElementById(id)) {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.id = id;
                script.type = 'text/javascript';
                script.async = true;
                script.onload = () => {
                    resolve();
                };
                script.onerror = (err) => {
                    reject(err);
                };
                script.src = sourceUrl;
                this._injectedElements.push(script);
                document.getElementsByTagName('head')[0].appendChild(script);
            });
        });
        this._setupResizeListener = () => __awaiter(this, void 0, void 0, function* () {
            window.addEventListener('resize', utils_1.debounce((event) => __awaiter(this, void 0, void 0, function* () {
                const size = yield this._getWindowSize();
                return this._postMessageToChild({
                    method: 'onResize',
                    params: size
                });
            }), 100));
        });
        this._cacheLoginKeyAddress = () => __awaiter(this, void 0, void 0, function* () {
            const loginKey = yield this._postMessageToChild({
                method: 'getOrCreateLoginKey'
            });
            this.cachedLoginKeyAddress = loginKey.publicAddress;
        });
        this._cacheAccountAddress = () => __awaiter(this, void 0, void 0, function* () {
            const accountAddress = yield this._postMessageToChild({
                method: 'getAccountAddress'
            });
            this.cachedAccountAddress = accountAddress;
        });
        this._cacheIsAuthenticated = () => __awaiter(this, void 0, void 0, function* () {
            const isAuthenticated = yield this._postMessageToChild({
                method: 'isAuthenticated'
            });
            this.cachedIsAuthenticated = isAuthenticated;
        });
        // NOTE: to prevent pop-ups from being blocked, there must be no awaits from
        // click to window.open, meaning value lookups must be cached before the
        // login method is called.
        this.login = utils_1.throttle(() => __awaiter(this, void 0, void 0, function* () {
            yield this._tilConfigReady();
            yield this._tilReady();
            if (!this.cachedIsAuthenticated) {
                // NOTE: if not logged in to dapp, then proceed to login
                yield this._signLoginKeyRequest(this.cachedLoginKeyAddress);
                return this.getAuthenticatedAccount();
            }
            else {
                // only show one already logged in notification at a time
                if (!this.notificationsMap['loggedIn']) {
                    const notification = this.notifier.notify({
                        type: 'success',
                        message: 'You are logged into Authereum',
                        timeout: 5000
                    });
                    this.notificationsMap['loggedIn'] = notification;
                    setTimeout(() => {
                        this.notificationsMap['loggedIn'] = null;
                    }, 5e3);
                }
            }
            // await first
            const account = yield this.getAuthenticatedAccount();
            return account;
        }), 250);
        this.authenticate = () => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.authenticate()` is deprecated. Use `authereum.login()` instead.');
            return this.login();
        });
        this.isAuthenticated = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'isAuthenticated'
            }));
        });
        this.logout = () => __awaiter(this, void 0, void 0, function* () {
            const res = yield this._postMessageToChild({
                method: 'logout'
            });
            yield this._resetCache();
            this.emit('logout', {});
            return res;
        });
        this.getAuthenticatedAccount = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getAuthenticatedAccount'
            }));
        });
        this.getDappKey = () => {
            return this._handleError(this._postMessageToChild({
                method: 'getLoginKey'
            }));
        };
        this.getLoginKey = () => {
            console.warn('Deprecation notice: `authereum.getLoginKey()` is deprecated. Use `authereum.getDappKey()` instead.');
            return this.getDappKey();
        };
        this.signWithDappKey = utils_1.throttle((message) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'signWithLoginKey',
                params: message
            }));
        }), 250);
        this.signWithLoginKey = utils_1.throttle((message) => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.signWithLoginKey()` is deprecated. Use `authereum.signWithDappKey()` instead.');
            return this.signWithDappKey(message);
        }), 250);
        this.signTypedMessageWithDappKey = utils_1.throttle((message) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'signTypedMessageWithLoginKey',
                params: message
            }));
        }), 250);
        this.signMessageWithAdminKey = utils_1.throttle((message) => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecated: `authereum.signMessageWithAdminKey()` is deprecated. Use `authereum.signMessageWithSigningKey()` instead.');
            return null;
        }), 250);
        this.signMessageWithSigningKey = utils_1.throttle((message) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'signMessageWithSigningKey',
                params: message
            }));
        }), 250);
        this.getLoginKeyAuthSignature = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getLoginKeyAuthSignature'
            }));
        });
        this.getLoginKeyRestrictionsData = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getLoginKeyRestrictionsData'
            }));
        });
        this.getAccountAddress = () => __awaiter(this, void 0, void 0, function* () {
            // required so it waits for login key to be set
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'getAccountAddress'
            }));
        });
        this.getBalance = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getBalance'
            }));
        });
        this.getRpcUri = () => __awaiter(this, void 0, void 0, function* () {
            yield this._tilConfigReady();
            return this.rpcUri;
        });
        this.getNetworkId = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getNetworkId'
            }));
        });
        this.getNetworkName = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getNetworkName'
            }));
        });
        this.getProvider = () => {
            return this.provider;
        };
        this._handleError = (promise) => __awaiter(this, void 0, void 0, function* () {
            return promise
                .catch((err) => {
                // NOTE: emit errors but don't throw notification here.
                this.emit('error', err);
                // NOTE: rethrow error to let dapps handle error
                throw err;
            });
        });
        this.signTransactionWithLoginKey = utils_1.throttle((tx) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'signTransactionWithLoginKey',
                params: serializeMessageObj(tx)
            }));
        }), 250);
        this.sendTransaction = utils_1.throttle((userTransaction) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'sendTransaction',
                params: serializeMessageObj(userTransaction)
            }));
        }), 250);
        this.sendTransactionBatch = utils_1.throttle((userTransactions) => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'sendTransactionBatch',
                params: userTransactions.map(serializeMessageObj)
            }));
        }), 250);
        this.estimateGasBatch = utils_1.throttle((userTransactions) => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'estimateGasBatch',
                params: userTransactions.map(serializeMessageObj)
            }));
        }), 250);
        this.isReady = () => {
            return this.iframeReady && this.cacheReady;
        };
        this.updateConfig = (config) => {
            this._userConfig = config;
            this._setConfig(config);
        };
        this.getConfig = () => {
            return {
                apiUri: this.apiUri,
                rpcUri: this.rpcUri,
                webUri: this.webUri,
                xsUri: this.xsUri,
                networkName: this.networkName,
                networkId: this.networkId,
                disableNotifications: this.disableNotifications
            };
        };
        this.showWidget = (enabled = true) => {
            if (!enabled) {
                return this.hideWidget();
            }
            this._widgetEnabled = true;
            this._refreshWidget();
            return true;
        };
        this.hideWidget = () => {
            this._widgetEnabled = false;
            // this.setIframePositionTop(this._getWindowHeight())
            // this.setIframePositionLeft(this._getWindowWidth())
            this.setIframeWidth(0);
            this.setIframeHeight(0);
            return true;
        };
        this.widgetEnabled = () => {
            return this._widgetEnabled;
        };
        this._tilIframeReady = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.iframeReady) {
                yield utils_1.wait(100);
                return this._tilIframeReady();
            }
            yield utils_1.wait(100);
            return true;
        });
        this._tilConfigReady = () => __awaiter(this, void 0, void 0, function* () {
            if (!this._configReady) {
                yield utils_1.wait(100);
                return this._tilConfigReady();
            }
            yield utils_1.wait(100);
            return true;
        });
        this._tilReady = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.isReady()) {
                yield utils_1.wait(100);
                return this._tilReady();
            }
            yield utils_1.wait(100);
            return true;
        });
        this._emitReadyEvent = () => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            if (this.readyEmitted)
                return;
            this.readyEmitted = true;
            this.emit('ready', {});
        });
        this._connectToChildIframe = () => __awaiter(this, void 0, void 0, function* () {
            if (this.iframeConnecting) {
                return this.iframeConnecting;
            }
            this.iframeReady = false;
            this.iframeConnecting = true;
            const iframe = yield this._getOrCreateIframe();
            this.iframeConnection = penpal_1.default.connectToChild({
                iframe,
                timeout: 60e3,
                methods: {
                    // NOTE: the postMessage penpal method should be the only method that
                    // exists.
                    postMessage: (data) => {
                        return this._handlePostMessage(data);
                    }
                }
            });
            this.iframeConnecting = new Promise((resolve, reject) => {
                let timedout = false;
                const timer = setTimeout(() => {
                    if (!this.iframeReady) {
                        timedout = true;
                        this.iframeConnecting = null;
                        reject(new Error('timedout'));
                    }
                }, 3e3);
                this.iframeConnection.promise.then((child) => {
                    clearTimeout(timer);
                    if (timedout) {
                        return;
                    }
                    this.iframeReady = true;
                    this.childIframeConnection = child;
                    this._startHeartbeat();
                    this.iframeConnecting = null;
                    resolve();
                })
                    .catch((err) => {
                    clearTimeout(timer);
                    if (timedout) {
                        return;
                    }
                    reject(err);
                });
            });
            return this.iframeConnecting;
        });
        this._startHeartbeat = (reconnect = false) => {
            if (!this._heartbeatStarted) {
                this._heartbeat(reconnect);
                this._heartbeatStarted = true;
            }
        };
        this._heartbeat = (reconnect = false) => __awaiter(this, void 0, void 0, function* () {
            if (this._destroyed) {
                return;
            }
            yield utils_1.wait(2e3);
            try {
                if (reconnect) {
                    yield this._connectToChildIframe();
                    this._backoffTimeout = 1;
                    return this._heartbeat();
                }
                yield this._ping();
            }
            catch (err) {
                // reconnect on destroyed connection error or ping timeout error
                if (/destroy|timedout/gi.test(err.message)) {
                    yield utils_1.wait(this._backoffTimeout * 1e3);
                    // exponential backoff
                    this._backoffTimeout = this._backoffTimeout << 1;
                    return this._heartbeat(true);
                }
            }
            return this._heartbeat();
        });
        this._ping = () => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let timedout = false;
                const timer = setTimeout(() => {
                    timedout = true;
                }, 5e3);
                this._postMessageToChild({
                    method: 'ping'
                }).then((pong) => {
                    clearTimeout(timer);
                    if (timedout) {
                        reject(new Error('timedout'));
                        return;
                    }
                    if (pong !== 'pong') {
                        reject(new Error('Invalid response'));
                        return;
                    }
                    resolve(pong);
                })
                    .catch(err => {
                    reject(err);
                });
            });
        });
        this._getConfigFromChild = () => __awaiter(this, void 0, void 0, function* () {
            return this._postMessageToChild({
                method: 'getConfig'
            });
        });
        this._postVersionToChild = () => __awaiter(this, void 0, void 0, function* () {
            return this._postMessageToChild({
                method: 'version',
                params: this.version()
            });
        });
        this._postApiKeyToChild = () => __awaiter(this, void 0, void 0, function* () {
            if (!this._apiKey)
                return;
            return this._postMessageToChild({
                method: 'apiKey',
                params: this._apiKey
            });
        });
        this._loadAsymmetricEncryptionKeyFromChild = () => __awaiter(this, void 0, void 0, function* () {
            this._asymmetricEncryptionKey = yield this._postMessageToChild({
                method: 'getAsymmetricEncryptionKey'
            });
        });
        this._postMessageToChild = (data) => __awaiter(this, void 0, void 0, function* () {
            if (this._destroyed) {
                throw new Error('Authereum instance destroyed.');
            }
            yield this._tilIframeReady();
            return this._handleError(this.childIframeConnection.postMessage(data));
        });
        this._handleChildLogoutEvent = () => __awaiter(this, void 0, void 0, function* () {
            yield this._resetCache();
            this.emit('logout', {});
        });
        this._handleChildDappKeyExpired = (loginKeyAddress) => __awaiter(this, void 0, void 0, function* () {
            if (loginKeyAddress === this.cachedLoginKeyAddress) {
                yield this._resetCache();
                this.emit('dappKeyExpired', loginKeyAddress);
                this.emit('logout');
            }
        });
        this._handlePostMessage = (data) => {
            try {
                const { method, params } = data;
                switch (method) {
                    case 'onError':
                        const err = params;
                        this.emit('error', err);
                        this.notifier.notify({
                            type: 'error',
                            message: err.message
                        });
                        return;
                    case 'onLogout':
                        return this._handleChildLogoutEvent();
                    case 'onDappKeyExpired':
                        return this._handleChildDappKeyExpired(params);
                    case 'login':
                        return this.login();
                    case 'setWidgetPosition':
                        /*
                        const position = params
                        const { x, y } = position
                        this.iframeStyle.left = x
                        this.iframeStyle.top = y
                        // this._refreshWidget()
                       */
                        return;
                    case 'setWidgetSize':
                        const size = params;
                        const { width, height } = size;
                        this.iframeStyle.width = width;
                        this.iframeStyle.height = height;
                        return this._refreshWidget();
                    case 'getWindowSize':
                        return this._getWindowSize();
                    case 'hideWidget':
                        return this.hideWidget();
                    case 'notification':
                        return this._handlePostMessageNotification(params);
                    case 'updateNotificationId':
                        return this._handlePostMessageUpdateNotificationId(params);
                    case 'updateNotification':
                        return this._handlePostMessageUpdateNotification(params);
                    case 'dismissNotification':
                        return this._handlePostMessageDismissNotification(params);
                    case 'log':
                        return this._handlePostMessageLog(params);
                    default:
                        break;
                }
            }
            catch (err) {
                // noop
            }
        };
        this._handlePostMessageNotification = (input) => {
            const notification = this.notifier.notify(input);
            if (input.id) {
                this.notificationsMap[input.id] = notification;
            }
        };
        this._handlePostMessageUpdateNotificationId = (input) => {
            let { id, newId } = input;
            this.notificationsMap[newId] = this.notificationsMap[id];
            this.notificationsMap[id] = null;
        };
        this._handlePostMessageUpdateNotification = (input) => {
            const notification = this.notificationsMap[input.id];
            if (notification) {
                notification.update(input);
            }
        };
        this._handlePostMessageDismissNotification = (input) => {
            const notification = this.notificationsMap[input.id];
            if (notification) {
                notification.dismiss();
            }
        };
        this._handlePostMessageLog = (data) => {
            let { type, message } = data;
            if (!type) {
                type = 'log';
            }
            console[type](message);
        };
        this._getWindowSize = () => {
            return {
                width: this._getWindowWidth(),
                height: this._getWindowHeight()
            };
        };
        this._getWindowWidth = () => {
            return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        };
        this._getWindowHeight = () => {
            return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        };
        /*
      public setIframePositionTop = (y: number) => {
        if (!this.iframe) return
        this.iframe.style.top = `${y}px`
      }
         */
        this.setIframePositionLeft = (x) => {
            if (!this.iframe)
                return;
            this.iframe.style.left = `${x}px`;
        };
        this.setIframeWidth = (width) => {
            if (!this.iframe)
                return;
            this.iframe.style.width = `${width}px`;
        };
        this.setIframeHeight = (height) => {
            if (!this.iframe)
                return;
            this.iframe.style.height = `${height}px`;
        };
        this._refreshWidget = () => {
            if (!this._widgetEnabled)
                return;
            const { top, left, width, height } = this.iframeStyle;
            // this.setIframePositionTop(top)
            // this.setIframePositionLeft(left)
            this.setIframeWidth(width);
            this.setIframeHeight(height);
        };
        this._loginKeyExists = () => __awaiter(this, void 0, void 0, function* () {
            return !!(yield this.getLoginKey());
        });
        this._accountAddressExists = () => __awaiter(this, void 0, void 0, function* () {
            return !!(yield this.getAccountAddress());
        });
        this._getAccountAdminKeyNonce = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getAccountAuthKeyNonce'
            }));
        });
        this._getAccountAuthKeyNonce = () => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum._getAccountAuthKeyNonce()` is deprecated. Use `authereum._getAccountAdminKeyNonce()` instead.');
            return this._getAccountAdminKeyNonce();
        });
        this._executeLoginKeyMetaTx = (tx) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'executeLoginKeyMetaTx',
                params: serializeMessageObj(tx)
            }));
        });
        this._loadLoginKey = (loginKey) => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'loadLoginKey',
                params: loginKey
            }));
        });
        this._getOrCreateLoginKey = () => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'getOrCreateLoginKey'
            }));
        });
        this._getAuthenticateUri = (loginKeyAddress) => {
            const encryptionKey = this._asymmetricEncryptionKey;
            // NOTE: slk = sign login key
            return this.webUri + '/?slk=' + encodeURIComponent(JSON.stringify({
                loginKey: {
                    publicAddress: loginKeyAddress,
                    // Convert to UTC to avoid local machine timezones
                    expiresAt: moment_1.default().add(1, 'month').utc().unix()
                },
                encryptionKey
            })) + '&redirect_uri=' + this.redirectUri;
        };
        this._getSignWithAdminKeyUri = (message) => {
            if (is_buffer_1.default(message)) {
                message = `0x${message.toString('hex')}`;
            }
            // NOTE: sm = sign message
            return this.webUri + '/?sm=' + encodeURIComponent(JSON.stringify({
                message
            })) + '&redirect_uri=' + this.redirectUri;
        };
        this._openPopupOrRedirect = (url) => __awaiter(this, void 0, void 0, function* () {
            this.emit('openPopup', {});
            const child = window.open(url, 'Authereum', `toolbar=no,
      location=no,
      status=no,
      menubar=no,
      scrollbars=no,
      resizable=no,
      width=470,
      height=640`);
            const isBlocked = (child === null || child === undefined);
            if (isBlocked && !this.blockedPopupRedirect) {
                const err = new Error('Disable popup blocker and try again');
                this.notifier.notify({
                    type: 'error',
                    message: err.message,
                    timeout: 5000
                });
                throw err;
            }
            else if (isBlocked) {
                this.emit('popupBlocked');
                // NOTE: if window is blocked then resort to redirect
                window.location.href = url;
                return;
            }
            child.focus();
            return new Promise((resolve, reject) => {
                const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                    if (child.closed) {
                        cleanUp();
                        const err = new Error('Window closed');
                        this.emit('error', err);
                        this.emit('closePopup', {});
                        reject(err);
                    }
                }), 250);
                const timeout = setTimeout(() => {
                    cleanUp();
                    child.close();
                    doneWithError(new Error('Timedout'));
                }, 10 * 60 * 1000);
                const cleanUp = () => {
                    clearInterval(interval);
                    clearTimeout(timeout);
                    this.emit('closePopup', {});
                };
                const doneWithError = (err) => {
                    cleanUp();
                    this.emit('error', err);
                    reject(err);
                };
                const done = (result = {}) => {
                    cleanUp();
                    resolve(result);
                };
                window.addEventListener('message', (event) => __awaiter(this, void 0, void 0, function* () {
                    if (event.origin.includes(this.webUri)) {
                        // this event tells parent to close child popup
                        if (event.data.close) {
                            child.close();
                            done();
                        }
                        if (event.data.login) {
                            done({ success: true });
                            this.emit('login', {});
                            this.cachedIsAuthenticated = true;
                            if (event.data.encryptedSigningKey) {
                                yield this._loadSigningKey(event.data.encryptedSigningKey);
                            }
                            this._logAnalyticsEvent({ eventType: 'logged_in_dapp', properties: { dapp_url: window.location.href } });
                            if (this.redirectUri !== window.location.href) {
                                window.location.href = this.redirectUri;
                            }
                        }
                        if (event.data.result) {
                            done(event.data.result);
                            if (this.redirectUri !== window.location.href) {
                                window.location.href = this.redirectUri;
                            }
                        }
                        if (event.data.error) {
                            doneWithError(new Error(event.data.error));
                            if (this.redirectUri !== window.location.href) {
                                window.location.href = this.redirectUri;
                            }
                        }
                    }
                }));
            });
        });
        this._signLoginKeyRequest = (publicAddress) => __awaiter(this, void 0, void 0, function* () {
            const url = this._getAuthenticateUri(publicAddress);
            return this._openPopupOrRedirect(url);
        });
        this._tilDomReady = () => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                if (document.readyState !== 'loading') {
                    resolve();
                }
                else {
                    document.addEventListener('DOMContentLoaded', () => resolve());
                }
            });
        });
        // keep both static and normal version methods
        this.version = () => {
            return version_1.default;
        };
        this.isAuthenticatedSync = () => {
            return this.cachedIsAuthenticated;
        };
        this.getTransactionReceipt = (txHash) => {
            return this._handleError(this._postMessageToChild({
                method: 'getTransactionReceipt',
                params: txHash
            }));
        };
        this.waitForTransactionReceipt = (txHash) => {
            return this._handleError(this._postMessageToChild({
                method: 'waitForTransactionReceipt',
                params: txHash
            }));
        };
        this.hasRecoveryEnabled = () => {
            return this._handleError(this._postMessageToChild({
                method: 'hasRecoveryEnabled'
            }));
        };
        this.isContractDeployed = (accountAddress) => {
            return this._handleError(this._postMessageToChild({
                method: 'isContractDeployed',
                params: accountAddress
            }));
        };
        this._loadSigningKey = (signingKey) => __awaiter(this, void 0, void 0, function* () {
            return this._postMessageToChild({
                method: 'loadSigningKey',
                params: signingKey
            });
        });
        this._logAnalyticsEvent = (input) => __awaiter(this, void 0, void 0, function* () {
            return this._postMessageToChild({
                method: 'logAnalyticsEvent',
                params: input
            });
        });
        this._setupSigningKey = () => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            const encryptedSigningKey = this._authereumQueryParams['encryptedSigningKey'];
            if (encryptedSigningKey) {
                yield this._loadSigningKey(encryptedSigningKey);
            }
        });
        this._cacheAuthereumQueryParams = () => __awaiter(this, void 0, void 0, function* () {
            try {
                const param = utils_1.getQueryParamValue('_authereum');
                if (param) {
                    this._authereumQueryParams = JSON.parse(param);
                    const newUrl = utils_1.removeQueryParam('_authereum');
                    utils_1.replaceWindowUrl(newUrl);
                }
            }
            catch (err) {
                // noop
            }
        });
        this.destroy = () => __awaiter(this, void 0, void 0, function* () {
            if (this._destroyed) {
                console.warn('Authereum instance already destroyed.');
                return true;
            }
            try {
                if (this.iframeReady) {
                    yield this._postMessageToChild({
                        method: 'destroy'
                    });
                }
            }
            catch (err) {
                console.error(err);
            }
            for (let i = 0; i < this._injectedElements.length; i++) {
                const element = this._injectedElements[i];
                try {
                    element.remove();
                }
                catch (err) {
                    console.error(err);
                }
            }
            const elements = document.querySelectorAll('[id*="authereum"]');
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                try {
                    element.remove();
                }
                catch (err) {
                    console.error(err);
                }
            }
            this.iframeReady = false;
            this._destroyed = true;
            console.warn('Authereum instance destroyed.');
            this.emit('destroy', {});
            return true;
        });
        this.isDestroyed = () => {
            return this._destroyed;
        };
        this.getAddressQrCodeDataUri = (address) => __awaiter(this, void 0, void 0, function* () {
            return this._postMessageToChild({
                method: 'getAddressQrCodeDataUri',
                params: {
                    address
                }
            });
        });
        this._userConfig = config;
        this._init(config);
    }
    _getOrCreateIframe() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.iframe) {
                if (this.iframeConnection) {
                    this.iframeConnection.destroy();
                }
                this.iframe.remove();
            }
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const id = `authereum__x-iframe--${utils_1.uuidv4()}`;
                const iframe = document.createElement('iframe');
                iframe.id = id;
                iframe.src = this.xsUri;
                iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');
                iframe.style.position = 'fixed';
                iframe.style.bottom = '0';
                iframe.style.right = '0';
                iframe.style.width = '0';
                iframe.style.height = '0';
                iframe.style.border = '0';
                iframe.style.background = 'transparent';
                iframe.style.zIndex = '1';
                iframe.setAttribute('frameborder', '0');
                iframe.setAttribute('scrolling', 'no');
                // iframe.style.outline = '1px solid red' // debug
                this.iframe = iframe;
                resolve(this.iframe);
                yield this._tilDomReady();
                document.body.appendChild(iframe);
                this._injectedElements.push(iframe);
                iframe.onload = () => {
                    this._postVersionToChild();
                    this._postApiKeyToChild();
                    this._loadAsymmetricEncryptionKeyFromChild();
                    this._getConfigFromChild()
                        .then((config) => {
                        this._setConfig(config);
                        this._configReady = true;
                        this.emit('iframeReady', {});
                    });
                };
            }));
        });
    }
}
exports.default = Authereum;
// keep both static and normal version methods
Authereum.version = () => {
    return version_1.default;
};
if (typeof window !== 'undefined') {
    window.Authereum = Authereum;
}
